# JavaInterwiewQuestions
Вопросы и ответы для подготовки к интервью и прохождения Ревью на JavaMentor

Теоретические вопросы для повторения: 
1. Все примитивные типы и их размеры 
1.	byte=8bit
2.	short=16bit
3.	int=32bit
4.	long=64
5.	char=16bit
6.	Boolean=16
7.	float=32
8.	double=64
9.	https://javarush.ru/groups/posts/1382-primitivnihe-tipih-java
2. Потери при неявных приведениях 
   нет
3. Что такое Autoboxing, unboxing и когда они происходят автоматически?  
       Процесс преобразования примитивных типов в ссылочные (int->Integer) 
  называется autoboxing (автоупаковкой), а обратный ему — unboxing (автораспаковкой). 
  Классы-обертки являются immutable (неизменяемыми): это означает, что после 
  создания объекта его состояние — значение поля value — не может быть изменено.
   Классы-обертки задекларированы как final: объекты, так сказать, read-only. 
  Также хотелось бы упомянуть, что от этих классов невозможно наследоваться. 
  Java автоматически делает преобразования между примитивными типами и их обертками:

4. Что такое continue и break? Расширенная версия ?
      https://javarush.ru/groups/posts/1389-operatorih-perekhoda

5. Какая размерность у boolean?
       1. В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 
         4 байта (32 бита), как и тип int. Однако, в определенных версиях JVM 
         имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту. 

6. Переведи число X (любое) из десятичной в двоичную, и число Y (любое) из двоичной в десятичную
     https://calculatori.ru/perevod-chisel.html 
        Любое число может быть легко переведено в десятичную систему по следующему алгоритму:
      Каждая цифра числа должна быть умножена на основание системы счисления этого числа 
      возведенное в степень равное позиции текущей цифры в числе справа налево, причём счёт 
      начинается с 0.
степени 2-ки   3      2    1  0
               1      1    1  1  ==     
             2*2*2 + 2*2 + 2 +1

         Из десятичной в двоичную систему переводим путем деления на 2 и далее 
       если есть остаток от деления есть - пишем 1 исли нет - пишем 0
       9/2  4/2  2/2              или 8/2 4/2 2/2
        1    0    0   1                0   0    1
        8  + 0  + 0 + 1                8 + 0  + 0 

7. Какие классы-обертки знаешь?
     byte     Byte
     short    Short  
     int      Integer 
     long     Long
     char     Character
     float    Float
     double   Double
     boolean  Boolean
    https://javarush.ru/groups/posts/1948-objertki-raspakovka-i-zapakovka
        Обертка — это специальный класс, который хранит внутри себя значение примитива.
       Но поскольку это именно класс, он может создавать свои экземпляры. 
       Они будут хранить внутри нужные значения примитивов,  
       при этом будут являться настоящими объектами
       http://java-online.ru/java-lang-wrapper.xhtml

8. Расскажи про pool строк и pool примитивов 
    Для более эффективного использования памяти в java используются так называемые пулы. 
   Есть строковый пул, Integer пул и т.д. Когда мы создаем объект не используя new, он помещается
   в пул и  в полседствии, если мы захотим создать такой же объект (не используя new) новый 
   не будет создан а мы просто получим ссылку из пула.
   Особенность Integer-пула  -- он хранит только числа, которые помещаются в топ данных byte
   от - 128 до 127 . Для остальных пул не работает.


9. Разница между String, StringBuilder и StringBuffer? 
	Объекты String являются неизменяемыми, поэтому все операции, 
      которые изменяют строки, фактически приводят к созданию новой строки,
      что сказывается на производительности приложения. Для решения этой
       проблемы, чтобы работа со строками проходила с меньшими издержками 
       в Java были добавлены классы StringBuffer и StringBuilder. По сути 
      они напоминает расширяемую строку, которую можно изменять без ущерба 
     для производительности.

     Эти классы похожи, практически двойники, они имеют одинаковые конструкторы,
      одни и те же методы, которые одинаково используются. Единственное их
      различие состоит в том, что класс StringBuffer синхронизированный и потокобезопасный.
     То есть класс StringBuffer удобнее использовать в многопоточных приложениях,
     где объект данного класса может меняться в различных потоках. Если же речь о
     многопоточных приложениях не идет, то лучше использовать класс StringBuilder, 
     который не потокобезопасный, но при этом работает быстрее, чем StringBuffer в
     однопоточных приложениях
     можно все делать  со строкой но потом вернуть строку через метод:  .toString();

10. Какая максимальная длина массива?
           Теоретически максимальный размер массива будет Integer.MAX_VALUE. 
            Практически это зависит от того, сколько памяти имеет ваш JVM и 
сколько из них уже выделено для других объектов.
12.  Максимальная размерность многомерного массива
      

11. Почему 0.1 0.7 != 0.8 ?  получим 0.7999999999999999


13. При сложении  char  short  какой результирующий тип получим? 
	Получим int
        Если в операциях участвуют данные типа char, то они преобразуются в int:
          int d = 'a' + 5;
          System.out.println(d);  // 102


14. Отличие операторов сокращенных логических операторов и полных  
     полные операторы проверяют по умолчанию обе стороны выражения
    сокращенняые как && || - только одну, имеет большое значение при выполнении методов

15. Где находятся параметры и аргументы метода
      Обычно параметр является тем, что появляется в определении метода.
      Аргумент - это экземпляр, переданный методу во время выполнения.

16. Размер boolean-значенией в массиве типов boolean
    В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean 
    занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM 
    имеются реализации, где в массиве boolean каждое значение 
      занимает    по     1-му     биту.

    Я полагаю, что это сделано как баланс между скоростью и удобством. 
    То есть одиночный тип boolean рассматривается как int, а массив, рассматривается
    как массив byte, а кое где и вовсе как бит

17.  Перевод 1111 в десятичную систему и обратно 
          15

18.  Оператор XOR. Представить таблицу истинности для него 
		True если хотя бы один true

20.  Что такое явные и неявные приведения, с чем связано их наличие? 
       Каждый базовый тип данных занимает определенное количество байт памяти.
       Это накладывает ограничение на операции, в которые вовлечены различные типы данных.
       
       Автоматически без каких-либо проблем производятся расширяющие преобразования (widening)
   - они расширяют представление объекта в памяти. Например:
   byte b = 7;
   int d = b;  // преобразование от byte к int 
   В данном случае значение типа byte, которое занимает в памяти 1 байт, расширяется 
   до типа int, которое занимает 4 байта.

   Расширяющие автоматические преобразования представлены следующими цепочками:

   byte -> short -> int -> long
   int -> double
   short -> float -> double
   char -> int
   Автоматические преобразования с потерей точности

   Некоторые преобразования могут производиться автоматически между 
   типами данных одинаковой разрядности или даже от типа данных с большей 
   разрядностью к типа с меньшей разрядностью. Это следующие цепочки преобразований:
   int -> float, long -> float и long -> double. Они производятся без ошибок, 
    но при преобразовании мы можем столкнуться с потерей информации.

   int a = 2147483647;
   float b = a;            // от типа int к типу float
   System.out.println(b);  // 2.14748365E9

Преобразования при операциях
   Нередки ситуации, когда приходится применять различные операции, например, сложение
   и произведение, над значениями разных типов. Здесь также действуют некоторые правила:

  если один из операндов операции относится к типу double, то и второй операнд 
   преобразуется к типу double

   если предыдущее условие не соблюдено, а один из операндов операции относится к
   типу float, то и второй операнд преобразуется к типу float

  если предыдущие условия не соблюдены, один из операндов операции относится к 
  типу long, то и второй операнд преобразуется к типу long

  иначе все операнды операции преобразуются к типу int

21.  Какие данные мы рискуем потерять при явных приведениях?
     при явно преобразовании необходимо учитывать разрядность числа и
    наличие знаков после запятой
    
23. Логические операторы.
 &  end
 |   or
 ^ xor
 !  not
24. Что такое char? Почему над ним можно выполнять арифметические операции?
	Имеет целочисленное неотрицательное значение 16 bit  от 0 до 
	Представляет номер символа в системе Unicode
        Чтобы получить код символа, достаточно выполнить приведение к типу int: 
        char ch = 'n'; 
        System.out.println((int)ch); 

25.  Неизменяемые типы
     String, типы-Обертки,
    от них нельзя наследовться
    можно сделать свойнеизменяемый класс
     1. ссылочные поля копировать через клон
     2. поля должны быть private и finale
     3. задаваться значения только через конструктор
     4. только сеттеры
     5. класс должен быть тоже finale
26.  Почему не рекомендуются множественные конкатенации String?
      Больше Затрат  по памяти и  времени 

27.  чем отличается метод от функции? 
           ничем

28.  можно ли положить максимальное значение long во float
      можно с потерей точности

29.  byte a = 1; byte b = 2; byte c = a b; Будут ли какие-то проблемы? 
       будет int или переполнение с явным преобразованием

30. Как добавить String’у в pool строк?
     использование оператора new заставляет класс String создать 
     новый объект String. После этого можем 
     использовать метод    intern(),    чтобы поместить этот объект в пул строк
     или обратиться к другому объекту из пула строк, который имеет такое же значение.

32.  Что такое массив и какие на нём есть ограничения?
      
       

33.  Расскажи про все условные операторы?
    while (true) {
     ..};
     do {...} while(true);
       if(true){
     ..} if() {
     ..} else if () {
       }
   switch(.) {
      case: ..
    break;
      };
34.  Отличия for от for each 
      цикл for -это конструкция, которая говорит: 
         "выполните эту операцию n раз ".

          цикл foreach - это конструкция, которая говорит 
          "perform this operation against each value/object in this IEnumerable"
     или
        foreach используется для перебора каждого элемента заданного набора
    или списка (все, что реализует IEnumerable ) предопределенным образом.
   Вы не можете повлиять на точный порядок (кроме пропуска записей или отмены 
   всего цикла), поскольку это определяется контейнером.

   а  for -это просто еще один способ написать цикл, код которого выполняется
   перед входом в цикл и один раз после каждой итерации. Обычно он используется 
   для циклического перебора кода заданное количество раз. В отличие от foreach    
   здесь вы можете влиять на текущую позицию.

35.  Потеря данных при преобразовании short/char
       тип byte не преобразуется автоматически (не явно) в тип char, хотя тип byte имеет 
     ширину 8 бит, а char - 16. То же самое касается и преобразования типа 
     short в char. Это происходит потому, что byte и short знаковые типы данных,
     а char беззнаковый. Поэтому в данном случае требуется использовать явное 
      приведение типов, поскольку компилятору надо явно указать, что вы знаете 
     чего хотите и как будет обрабатываться знаковый бит типов byte и short при
    преобразовании к типу char.

    Поведение величины типа char в большинстве случаев совпадает с поведением
     величины целого типа, следовательно, значение типа char можно использовать  
    везде, где требуются значения int или long. Однако напомним, что тип char не 
    имеет знака, поэтому он ведет себя отлично от типа short, несмотря на то что 
    диапазон обоих типов равен 16 бит

36.  Инкременты, декременты, отличия. 

37.  Пулы строк и integer 

38. Что такое рекурсия? Недостатки и преимущества? 

39. 2 случая (правила/условия) в рекурсивном алгоритме?

40. Какие могут быть потери данных при явных привидениях? 

41. Double to int 
     произойет потеря значений после запятой без округления

42. Расширенный break
 
43. Continue \ break  
    Оператор continue позволяет перейти к следующей итерации цикла до завершения 
    выполнения всех инструкций внутри цикла. В качестве примера выведем все числа 
     от 1 до 100, кроме чисел от 5 до 10 включительно

   Оператор break позволяет прервать выполнение цикла досрочно. Для примера вы-
  ведем все числа от 1 до 100 еще одним способом: 
    int i = 1; 
   while (true) { 
   if (i > 100) break; 
   System.out.println(i); 
   i++; 
} 
  Здесь мы в условии указали значение true. В этом случае инструкции внутри цикла 
  будут выполняться бесконечно. Однако использование оператора break прерывает 
  его выполнение, как только 100 строк уже напечатано.   
  ВНИМАНИЕ! 
  Оператор break прерывает выполнение цикла, а не программы, т. е. далее будет вы-
  полнена инструкция, следующая сразу за циклом. 
  Бесконечный цикл совместно с оператором break удобно использовать для получе-
  ния неопределенного заранее количества данных от пользователя. В качестве при-
  мера просуммируем неопределенное количество целых чисел (листинг 3.8). 


3) ради интереса - размер объекта оберток и прочих

 Дополнительные темы (выпишите себе ответы в отдельный файл) 
 Вещественные числа: 
Большие числа BigInteger и BigDecimal 

Преобразование базовых типов данных:

Автоматическое привидение типов: 

Примитивные типы:
  
Integer  pool:
 
Явноие привидение типов: 
String pool: 

String: 

Логические операторы в Java: 

Пример immutable класса:  

Многомерные массивы: 

Побитовые операции:

